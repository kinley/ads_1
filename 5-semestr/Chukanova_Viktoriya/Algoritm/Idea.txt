/**
 * Задача: Оставное дерево наименьшей стоимости.
 * Инструменты: Множества с операциями «Вставить-Удалить-Объеденить -MIN», реализация сливаемыми 2-3 деревьями.
 * Автор: Чуканова Виктория, 1 курс, группа 09-308, направление "Программная инженерия", институт ВМиИТ, КФУ.
 *
 * Вся программа состоит из 8 классов:
 * - Инструменты: free(бинарное дерево), Union(Объединие), Bag(Контейнер).
 * - Входные-выходные данные: SOut(Системный вывод), SIn(Системный ввод), MainPQ(реализация очереди с приоритетами)
 * - Главная часть: Prim(алгоритм Прима)
 * - Головная программа Main. 
 * 
 * Использованная литература:
 * 1. Роберт Седжвик, Кевин Уэйн - Алгоритмы на Java - 2013. Глава 4.3. Минимальное остовное дерево.
 * 2. Ахо А., Хопкрофт Дж., Ульман Дж. Построение и анализ вычислительных алгоритмов. – М.: МИР, 1979. Глава 5.1. 
 */
Задача решалась при помощи бинарного дерева.(класс free)
Бинарное дерево — это динамическая структура данных, состоящая из узлов, каждый из которых содержит, кроме данных, 
не более двух ссылок на различные бинарные деревья. На каждый узел имеется ровно одна ссылка. 
Начальный узел называется корнем дерев
Высота дерева определяется количеством уровней, на которых располагаются его узлы. 
Если дерево организовано таким образом, что для каждого узла все ключи его левого 
поддерева меньше ключа этого узла, а все ключи его правого поддерева - больше,
 оно называется деревом поиска. Одинаковые ключи не допускаются. В дереве поиска можно найти элемент по ключу, 
двигаясь от корня и переходя на левое или правое поддерево в зависимости от значения ключа в каждом узле. 
Такой поиск гораздо эффективнее поиска по списку, поскольку время поиска определяется высотой дерева, а она пропорциональна двоичному логарифму количества узлов.
Для бинарных деревьев определены операции:
• включения узла в дерево;
• поиска по дереву;
• обхода дерева;
• удаления узла.
Нерекурсивная функция поиска по дереву с включением и рекурсивная функция обхода дерева. 
Программа формирует дерево из массива целых чисел и выводит его на экран. 

Первая функция осуществляет поиск элемента с заданным ключом. Если элемент найден, она возвращает указатель на него, 
а если нет — включает элемент в соответствующее место дерева и возвращает указатель на него. 

Для включения элемента необходимо помнить пройденный по дереву путь на один шаг назад и знать, 
выполняется ли включение нового элемента в левое или правое поддерево его предка.
Текущий указатель для поиска по дереву обозначен pv, указатель на предка pv обозначен prev, 
переменная pnew используется для выделения памяти под включаемый в дерево узел. 
Рекурсии удалось избежать, сохранив всего одну переменную (prev) и 
повторив при включении операторы, определяющие, к какому поддереву присоединяется новый узел. 

Рассмотрим подробно функцию обхода дерева. Вторым параметром в нее передается целая переменная, определяющая, 
на каком уровне находится узел. Корень находится на уровне 0. Дерево печатается по горизонтали так, что корень находится слева. 


Перед значением узла для имитации структуры дерева выводится количество пробелов, пропорциональное уровню узла. 
Если закомментировать цикл печати пробелов, отсортированный по возрастанию массив будет выведен в столбик. 
Функция обхода дерева длиной всего в несколько строк может напечатать дерево любого размера — ограничением является только размер 
стека.


***


Алгоритм Прима(класс Prim)
Этот алгоритм назван в честь американского математика Роберта Прима (Robert Prim), который открыл этот алгоритм в 1957 г. 
Впрочем, ещё в 1930 г. этот алгоритм был открыт чешским математиком Войтеком Ярником (Vojtech Jarnik). К
роме того, Эдгар Дейкстра (Edsger Dijkstra) в 1959 г. также изобрёл этот алгоритм, независимо от них.

Описание алгоритма:
Сам алгоритм имеет очень простой вид. Искомый минимальный остов строится постепенно, добавлением в него рёбер по одному. 
Изначально остов полагается состоящим из единственной вершины (её можно выбрать произвольно). 
Затем выбирается ребро минимального веса, исходящее из этой вершины, и добавляется в минимальный остов. 
После этого остов содержит уже две вершины, и теперь ищется и добавляется ребро минимального веса, 
имеющее один конец в одной из двух выбранных вершин, а другой — наоборот, во всех остальных, кроме этих двух. 
И так далее, т.е. всякий раз ищется минимальное по весу ребро, один конец которого — уже взятая в остов вершина, 
а другой конец — ещё не взятая, и это ребро добавляется в остов (если таких рёбер несколько, можно взять любое). 
Этот процесс повторяется до тех пор, пока остов не станет содержать все вершины (или, что то же самое, n-1 ребро).

В итоге будет построен остов, являющийся минимальным. Если граф был изначально не связен, то остов найден не будет 
(количество выбранных рёбер останется меньше n-1).

Реализации
Время работы алгоритма существенно зависит от того, каким образом мы производим поиск очередного минимального ребра 
среди подходящих рёбер. Здесь могут быть разные подходы, приводящие к разным асимптотикам и разным реализациям.


В описанном мною алгоритме можно увидеть стандартные операции нахождения минимума в множестве и изменение значений в этом множестве.
Эти две операции являются классическими, и выполняются многими структурами данных, например, реализованным красно-чёрным деревом set.

По смыслу алгоритм остаётся точно таким же, однако мы можем найти минимальное ребро за время O(\log n). 
С другой стороны, время на пересчёт n указателей составит O(n \log n).


Реализация алгоритма Прима для графа, заданного списками смежности g[]:
На вход подаются число вершин n и n списков смежности: g[i] — это список всех рёбер, исходящих из вершины i, 
в виде пар (второй конец ребра, вес ребра). Алгоритм поддерживает два массива: величина {\rm min\_e}[i] 
хранит вес наименьшего допустимого ребра из вершины i, а элемент {\rm sel\_e}[i] содержит конец этого наименьшего ребра 
(это нужно для вывода рёбер в ответе). Кроме того, поддерживается очередь q из всех вершин в порядке увеличения их меток {\rm min\_e}. Алгоритм делает n шагов, на каждом из которых выбирает вершину v с наименьшей меткой {\rm min\_e} (просто извлекая её из начала очереди), и затем просматривает все рёбра из этой вершины, пересчитывая их метки (при пересчёте мы удаляем из очереди старую величину, и затем кладём обратно новую).

